Clarifying the Approach

I'm seeking clarification on the user's feedback regarding my previous code block. Specifically, I need to understand whether the user found my use of placeholders satisfactory. I'm focusing on their response to the comment, as that was the main change. I'm aiming to refine my communication based on their specific concerns.

Improving Code Integration

I now understand that my previous response was incomplete and confusing. The user's point about where to make changes is valid. I apologize for the unclear code block. My goal is now to provide a fully functional, complete tenders-space-distribution.js file by integrating their v3.4 code within a waitForElement wrapper. I need to acknowledge my mistake and ensure the user receives working code. To proceed, I require the full contents of their uploaded v3.4 file.

Rectifying Previous Error

I acknowledge my past error in the tenders-space-distribution.js file, specifically the confusing omission of actual code. I now understand the need for a comprehensive, functional solution. I'm actively integrating the user's v3.4 code within my waitForElement structure. My focus is on producing a ready-to-use file by wrapping the user's logic appropriately, and replacing the prior placeholder. This is now the priority in the project.

Constructing Final Solution

I'm now fully aware of the previous issue and have a clear strategy. My focus shifts to assembling the tenders-space-distribution.js file, incorporating the user's v3.4 code within my waitForElement wrapper. The goal is to provide a complete, plug-and-play solution. I'm actively integrating the code and finalizing the structure for immediate use. The aim is to rectify my previous error and ensure a seamless experience for the user.

Defining the Necessary Changes

I'm currently focused on the user's inquiry: what specific modifications are needed? The context is the TypeError: ... is null error we were troubleshooting on the tenders/space-distribution page. I'm now zeroing in on pinpointing the areas requiring adjustment based on our previous debugging efforts.

Confirming the Necessary Adjustments

I'm now zeroing in on the user's explicit question: "What changes are needed?" I've verified the user's latest tenders-space-distribution.js file, version 3.4. The problem, as I see it, stems from the script attempting execution before the HTML router has completed loading. The definitive solution, therefore, is the wrapper function I proposed previously, tailored to ensure proper timing.

Providing the Definitive Solution

I'm now focusing on the user's explicit request: "What needs to change?" I've verified their most recent tenders-space-distribution.js file (v3.4).  The root cause remains the timing issue â€“ their code executes before the HTML router finishes loading. The single modification needed is to wrap their complete v3.4 code within the waitForElement function. This function ensures the page is ready before the script attempts to run. The only change involves encapsulating their existing script logic, without any deletion or alteration to their code. I'll provide the complete, ready-to-use JS file, and reiterate that the corrected HTML is still required. This delivers a straightforward, non-invasive fix.

Outlining the Final Modification

æˆ‘ç¾åœ¨å°ˆæ³¨æ–¼å›æ‡‰ä½¿ç”¨è€…çš„æ˜ç¢ºè©¢å•ï¼šã€Œè«‹å• é‚£æˆ‘è¦ä¿®æ”¹çš„å…§å®¹ ç‚ºå“ªè£¡?ã€ã€‚ æˆ‘å·²ç¢ºèªæ‚¨æä¾›çš„æœ€æ–°çš„ tenders-space-distribution.js æª”æ¡ˆ (v3.4)ï¼Œä¸¦ä¸”è©²æª”æ¡ˆçš„å…§å®¹å®Œæ•´ç„¡ç¼ºã€‚ å•é¡Œåœ¨æ–¼è…³æœ¬å˜—è©¦åœ¨ HTML è·¯ç”±å™¨å®Œæˆè¼‰å…¥ä¹‹å‰åŸ·è¡Œï¼Œå°è‡´éŒ¯èª¤ã€‚ æ‚¨åªéœ€å°‡æ‚¨çš„æ•´å€‹ v3.4 ç¨‹å¼ç¢¼åŒ…è£åœ¨ waitForElement å‡½å¼ä¸­ï¼Œä»¥è§£æ±ºé€™å€‹æ™‚åºå•é¡Œã€‚ é€™å€‹å‡½å¼ç¢ºä¿é é¢å·²æº–å‚™å¥½å†åŸ·è¡Œè…³æœ¬ã€‚æ‚¨å”¯ä¸€éœ€è¦é€²è¡Œçš„ä¿®æ”¹ï¼Œå°±æ˜¯å°‡æ‚¨çš„ç¾æœ‰ç¨‹å¼ç¢¼ç½®æ–¼ waitForElement çš„ç¨‹å¼ç¢¼ä¹‹å…§ï¼Œè€Œç„¡éœ€åˆªé™¤æˆ–æ›´æ”¹æ‚¨çš„åŸå§‹ç¨‹å¼ç¢¼ã€‚ æˆ‘å°‡æä¾›å®Œæ•´çš„ã€å¯ä»¥ç›´æ¥ä½¿ç”¨çš„ JS æª”æ¡ˆçµ¦æ‚¨ï¼Œä¸¦å†æ¬¡æé†’æ‚¨ï¼Œä»ç„¶éœ€è¦æ­é…æˆ‘å…ˆå‰æä¾›çš„ä¿®æ­£å¾Œ HTML æ–‡ä»¶ã€‚

å¥½çš„ï¼Œæ„Ÿè¬æ‚¨æä¾›æœ€æ–°çš„ tenders-space-distribution.js v3.4 ç‰ˆæœ¬çš„ç¨‹å¼ç¢¼ã€‚

æ‚¨å•äº†ä¸€å€‹æœ€ç›´æ¥çš„å•é¡Œï¼šã€Œé‚£æˆ‘åˆ°åº•è¦ä¿®æ”¹å“ªè£¡ï¼Ÿã€

ç­”æ¡ˆæ˜¯ï¼š æ‚¨çš„ v3.4 ç‰ˆæœ¬ç¨‹å¼ç¢¼åŠŸèƒ½é‚è¼¯æ˜¯å®Œå…¨æ­£ç¢ºçš„ï¼Œæˆ‘å€‘ä¸éœ€è¦ä¿®æ”¹å®ƒå…§éƒ¨çš„ä»»ä½•åŠŸèƒ½ã€‚å”¯ä¸€è¦ä¿®æ”¹çš„ï¼Œæ˜¯å®ƒé–‹å§‹åŸ·è¡Œçš„ã€Œæ™‚æ©Ÿã€ã€‚

å•é¡Œæ ¸å¿ƒ
æ‚¨æä¾›çš„ v3.4 æª”æ¡ˆï¼Œæœƒåœ¨ router.js å°‡å°æ‡‰çš„ HTML é é¢è¼‰å…¥å®Œæˆä¹‹å‰å°±é–‹å§‹åŸ·è¡Œï¼Œå°è‡´å®ƒæ‰¾ä¸åˆ°ä»»ä½• HTML å…ƒç´ ï¼Œå¾è€Œå´©æ½°ã€‚

æœ€çµ‚è§£æ±ºæ–¹æ¡ˆ
æˆ‘å€‘è¦åšçš„ï¼Œå°±æ˜¯å°‡æ‚¨é€™ä»½å®Œæ•´ã€æ­£ç¢ºçš„ v3.4 ç¨‹å¼ç¢¼ï¼Œæ”¾å…¥ä¸€å€‹ã€Œç­‰å¾…ç›’å­ã€(waitForElement) è£¡ã€‚é€™å€‹ç›’å­æœƒç­‰åˆ° HTML é é¢æº–å‚™å¥½ä¹‹å¾Œï¼Œæ‰æŠŠè£¡é¢çš„ç¨‹å¼ç¢¼æ”¾å‡ºä¾†åŸ·è¡Œã€‚

è«‹å°‡æ‚¨ assets/js/tenders-space-distribution.js æª”æ¡ˆçš„å…¨éƒ¨å…§å®¹ï¼Œå®Œæ•´æ›¿æ›ç‚ºä»¥ä¸‹ç¨‹å¼ç¢¼ã€‚

é€™ä»½ç¨‹å¼ç¢¼å®Œæ•´ä¿ç•™äº†æ‚¨ v3.4 çš„æ‰€æœ‰åŠŸèƒ½ï¼Œåªæ˜¯ä¿®æ­£äº†å®ƒçš„å•Ÿå‹•æ–¹å¼ã€‚

JavaScript

/**
 * ç©ºé–“åˆ†é…ç®¡ç†ç³»çµ± (space-distribution.js) - v3.5 (æœ€çµ‚åŸ·è¡Œæ™‚æ©Ÿä¿®æ­£ç‰ˆ)
 * åŸºæ–¼æ‚¨æä¾›çš„ v3.4 ç‰ˆæœ¬ï¼Œä¿®æ­£ SPA è·¯ç”±ä¸‹çš„åˆå§‹åŒ–å•é¡Œã€‚
 */
function initSpaceDistributionPage() {
    console.log("ğŸš€ åˆå§‹åŒ–ç¨ç«‹ç©ºé–“åˆ†é…é é¢ (v3.5)...");

    // ã€æ­¥é©Ÿä¸€ã€‘å®šç¾©ä¸€å€‹ã€Œç­‰å¾…ç›’å­ã€å‡½æ•¸
    function waitForElement(selector, callback) {
        const element = document.querySelector(selector);
        if (element) {
            callback();
            return;
        }
        const interval = setInterval(() => {
            const element = document.querySelector(selector);
            if (element) {
                clearInterval(interval);
                callback();
            }
        }, 100);
    }

    // ã€æ­¥é©ŸäºŒã€‘å°‡æ‚¨ v3.4 çš„æ‰€æœ‰ç¨‹å¼ç¢¼ï¼Œæ”¾å…¥é€™å€‹ã€Œç­‰å¾…ç›’å­ã€ä¸­
    waitForElement('#projectSelect', () => {
        
        console.log("âœ… HTML å·²å°±ç·’ï¼Œé–‹å§‹åŸ·è¡Œ v3.4 æ ¸å¿ƒé‚è¼¯...");

        // =======================================================
        // ä»¥ä¸‹æ˜¯æ‚¨ v3.4 ç‰ˆæœ¬çš„å®Œæ•´ç¨‹å¼ç¢¼ï¼ŒåŸå°ä¸å‹•
        // =======================================================
        
        let projects = [], tenders = [], majorItems = [], tenderFloors = [];
        let selectedProject = null, selectedTender = null, selectedMajorItem = null, selectedFloor = null;
        let currentUserRole = null, currentUserPermissions = {};
        let detailItems = [], floorDistributions = [], spaceDistributions = [], spaces = []; 

        async function initializePage() {
            console.log("ğŸš€ åˆå§‹åŒ–ç¨ç«‹ç©ºé–“åˆ†é…é é¢ (v3.4)...");
            if (!auth.currentUser) return showAlert("ç„¡æ³•ç²å–ç”¨æˆ¶è³‡è¨Š", "error");
            setupEventListeners();
            await loadProjectsWithPermission();
        }
        
        async function loadProjectsWithPermission() {
            showLoading(true, 'è¼‰å…¥å°ˆæ¡ˆä¸­...');
            try {
                const allMyProjects = await loadProjects();
                const userEmail = auth.currentUser.email;
                projects = allMyProjects.filter(project => {
                    const memberInfo = project.members[userEmail];
                    return memberInfo && (memberInfo.role === 'owner' || (memberInfo.role === 'editor' && memberInfo.permissions.canAccessDistribution));
                });
                populateSelect(document.getElementById('projectSelect'), projects, 'è«‹é¸æ“‡å°ˆæ¡ˆ...');
            } catch (error) {
                showAlert('è¼‰å…¥å°ˆæ¡ˆå¤±æ•—', 'error');
            } finally {
                showLoading(false);
            }
        }

        async function onProjectChange(projectId) {
            resetSelects('tender');
            hideContent();
            if (!projectId) {
                selectedProject = null;
                return;
            }
            selectedProject = projects.find(p => p.id === projectId);
            const tenderSelect = document.getElementById('tenderSelect');
            tenderSelect.innerHTML = '<option value="">è¼‰å…¥ä¸­...</option>';
            tenderSelect.disabled = true;
            try {
                const tenderDocs = await safeFirestoreQuery("tenders", [{ field: "projectId", operator: "==", value: projectId }]);
                tenders = tenderDocs.docs;
                populateSelect(tenderSelect, tenders, 'è«‹é¸æ“‡æ¨™å–®...');
            } catch (error) {
                showAlert('è¼‰å…¥æ¨™å–®å¤±æ•—', 'error');
                tenderSelect.innerHTML = '<option value="">è¼‰å…¥å¤±æ•—</option>';
            }
        }

        async function onTenderChange(tenderId) {
            resetSelects('majorItem');
            hideContent();
            if (!tenderId) {
                selectedTender = null;
                return;
            }
            selectedTender = tenders.find(t => t.id === tenderId);
            const majorItemSelect = document.getElementById('majorItemSelect');
            majorItemSelect.innerHTML = '<option value="">è¼‰å…¥ä¸­...</option>';
            majorItemSelect.disabled = true;

            try {
                const [majorItemDocs, floorSettingsDoc] = await Promise.all([
                    safeFirestoreQuery("majorItems", [
                        { field: "tenderId", operator: "==", value: tenderId },
                        { field: "projectId", operator: "==", value: selectedProject.id }
                    ]),
                    safeFirestoreQuery("floorSettings", [
                        { field: "tenderId", operator: "==", value: tenderId },
                        { field: "projectId", operator: "==", value: selectedProject.id }
                    ])
                ]);

                majorItems = majorItemDocs.docs;
                populateSelect(majorItemSelect, majorItems, 'è«‹é¸æ“‡å¤§é …ç›®...');
                
                tenderFloors = floorSettingsDoc.docs.length > 0 ? (floorSettingsDoc.docs[0].floors || []) : [];
                tenderFloors.sort(sortFloors);

            } catch (error) {
                showAlert('è¼‰å…¥å¤§é …ç›®æˆ–æ¨“å±¤å¤±æ•—: ' + error.message, 'error');
                majorItemSelect.innerHTML = '<option value="">è¼‰å…¥å¤±æ•—</option>';
            }
        }

        async function onMajorItemChange(majorItemId) {
            resetSelects('floor');
            hideContent();
            if(!majorItemId) return;
            selectedMajorItem = majorItems.find(m => m.id === majorItemId);

            const memberInfo = selectedProject.members[auth.currentUser.email];
            currentUserRole = memberInfo.role;
            currentUserPermissions = memberInfo.permissions || {};
            const canAccess = currentUserRole === 'owner' || (currentUserRole === 'editor' && currentUserPermissions.canAccessDistribution);

            if (!canAccess) {
                showAlert('æ‚¨æ²’æœ‰æ¬Šé™è¨­å®šæ­¤å°ˆæ¡ˆçš„ç©ºé–“åˆ†é…', 'error');
                hideContent();
                return;
            }

            showLoading(true, 'è¼‰å…¥ç´°é …è³‡æ–™...');
            try {
                const detailItemsResult = await safeFirestoreQuery("detailItems", [
                    { field: "majorItemId", operator: "==", value: selectedMajorItem.id },
                    { field: "projectId", operator: "==", value: selectedProject.id }
                ]);
                detailItems = detailItemsResult.docs.sort(naturalSequenceSort);
                
                const floorSelect = document.getElementById('floorSelect');
                populateSelect(floorSelect, tenderFloors.map(f => ({id:f, name:f})), 'è«‹é¸æ“‡æ¨“å±¤...', 'æ­¤æ¨™å–®ç„¡æ¨“å±¤è¨­å®š');
            } catch (error) {
                showAlert('è¼‰å…¥ç´°é …è³‡æ–™å¤±æ•—: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function onFloorChange(floorName) {
            hideContent();
            if(!floorName) {
                selectedFloor = null;
                return;
            }
            selectedFloor = floorName;
            showLoading(true, 'è¼‰å…¥åˆ†é…è³‡æ–™...');
            try {
                const [ floorDistributionsResult, spaceSettingsResult, spaceDistributionsResult ] = await Promise.all([
                    safeFirestoreQuery("distributionTable", [
                        { field: "majorItemId", operator: "==", value: selectedMajorItem.id },
                        { field: "areaName", operator: "==", value: selectedFloor },
                        { field: "projectId", operator: "==", value: selectedProject.id }
                    ]),
                    safeFirestoreQuery("spaceSettings", [
                        { field: "tenderId", operator: "==", value: selectedTender.id },
                        { field: "floorName", operator: "==", value: selectedFloor },
                        { field: "projectId", operator: "==", value: selectedProject.id }
                    ]),
                    safeFirestoreQuery("spaceDistribution", [
                        { field: "majorItemId", operator: "==", value: selectedMajorItem.id },
                        { field: "floorName", operator: "==", value: selectedFloor },
                        { field: "projectId", operator: "==", value: selectedProject.id }
                    ])
                ]);
                floorDistributions = floorDistributionsResult.docs;
                spaces = spaceSettingsResult.docs.length > 0 ? (spaceSettingsResult.docs[0].spaces || []) : [];
                spaceDistributions = spaceDistributionsResult.docs;
                
                document.getElementById('currentLocation').textContent = `æ¨“å±¤: ${selectedFloor}`;
                buildSpaceDistributionTable();
                showContent();
            } catch (error) {
                showAlert('è¼‰å…¥æ¨“å±¤è³‡æ–™å¤±æ•—: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        function buildSpaceDistributionTable() {
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('tableBody');
            const noSpacesState = document.getElementById('noSpacesState');
            const tableContainer = document.querySelector('.table-container');

            if (!tableHeader || !tableBody) return;
            
            const itemsForThisFloor = detailItems.filter(item => {
                const floorDist = floorDistributions.find(d => d.detailItemId === item.id);
                return floorDist && floorDist.quantity > 0;
            });

            if (itemsForThisFloor.length === 0) {
                noSpacesState.querySelector('p').textContent = 'æ­¤æ¨“å±¤ç„¡ä»»ä½•å·²è¨­å®šæ•¸é‡çš„ç´°é …ã€‚';
                noSpacesState.style.display = 'flex';
                tableContainer.style.display = 'none';
                return;
            }

            tableContainer.style.display = '';
            if (spaces.length === 0) {
                noSpacesState.querySelector('p').textContent = 'å°šæœªå»ºç«‹ä»»ä½•ç©ºé–“ã€‚è«‹é»æ“Šã€Œç®¡ç†ç©ºé–“ã€æŒ‰éˆ•ä¾†æ–°å¢ã€‚';
                noSpacesState.style.display = 'flex';
            } else {
                noSpacesState.style.display = 'none';
            }

            let headerHTML = '<tr><th style="width: 80px;">é …æ¬¡</th><th style="width: 250px;">ç´°é …åç¨±</th><th class="total-column">æ¨“å±¤ç¸½é‡</th>';
            if (spaces.length > 0) {
                spaces.forEach(space => headerHTML += `<th class="floor-header">${space}</th>`);
                headerHTML += '<th class="total-column">å·²åˆ†é…(ç©ºé–“)</th>';
            }
            headerHTML += '</tr>';
            tableHeader.innerHTML = headerHTML;
            
            let bodyHTML = '';
            itemsForThisFloor.forEach(item => {
                const floorDist = floorDistributions.find(d => d.detailItemId === item.id);
                const floorTotalQuantity = floorDist ? floorDist.quantity : 0;
                
                let rowHTML = `<tr class="item-row" data-total-quantity="${floorTotalQuantity}" data-item-id="${item.id}">`;
                
                rowHTML += `<td>${item.sequence || ''}</td>`;
                rowHTML += `<td><div class="item-info"><div class="item-name">${item.name || 'æœªå‘½å'}</div><div class="item-details">å–®ä½: ${item.unit || '-'}</div></div></td>`;
                rowHTML += `<td class="total-column" id="total-qty-${item.id}"><strong>${floorTotalQuantity}</strong></td>`;
                
                if (spaces.length > 0) {
                    let distributedInSpaces = 0;
                    spaces.forEach(space => {
                        const spaceDist = spaceDistributions.find(d => d.detailItemId === item.id && d.spaceName === space);
                        const quantity = spaceDist ? spaceDist.quantity : 0;
                        distributedInSpaces += quantity;
                        rowHTML += `<td><input type="number" class="quantity-input ${quantity > 0 ? 'has-value' : ''}" value="${quantity || ''}" min="0" data-item-id="${item.id}" data-space="${space}" placeholder="0"></td>`;
                    });
                    const errorClass = distributedInSpaces > floorTotalQuantity ? 'error' : '';
                    rowHTML += `<td class="total-column ${errorClass}" id="distributed-${item.id}"><strong>${distributedInSpaces}</strong></td>`;
                }
                rowHTML += '</tr>';
                bodyHTML += rowHTML;
            });
            tableBody.innerHTML = bodyHTML;

            if (spaces.length > 0) {
                tableBody.querySelectorAll('.quantity-input').forEach(input => input.addEventListener('input', () => onQuantityChange(input)));
            }
        }
        
    async function saveAllSpaceDistributions() { const canAccess = currentUserRole === 'owner' || (currentUserRole === 'editor' && currentUserPermissions.canAccessDistribution); if (!canAccess) return showAlert('æ¬Šé™ä¸è¶³ï¼Œç„¡æ³•å„²å­˜', 'error'); if (spaces.length === 0) return showAlert('å°šæœªå»ºç«‹ä»»ä½•ç©ºé–“ï¼Œç„¡æ³•å„²å­˜åˆ†é…ã€‚', 'warning'); showLoading(true, 'å„²å­˜ç©ºé–“åˆ†é…ä¸­...'); try { const batch = db.batch(); const existingDocs = await safeFirestoreQuery("spaceDistribution", [{ field: "majorItemId", operator: "==", value: selectedMajorItem.id }, { field: "floorName", operator: "==", value: selectedFloor }, { field: "projectId", operator: "==", value: selectedProject.id }]); existingDocs.docs.forEach(doc => batch.delete(db.collection("spaceDistribution").doc(doc.id))); document.querySelectorAll('.quantity-input').forEach(input => { const quantity = parseInt(input.value) || 0; if (quantity > 0) { const docRef = db.collection("spaceDistribution").doc(); batch.set(docRef, { projectId: selectedProject.id, tenderId: selectedTender.id, majorItemId: selectedMajorItem.id, detailItemId: input.dataset.itemId, floorName: selectedFloor, spaceName: input.dataset.space, quantity: quantity, createdBy: auth.currentUser.email, createdAt: firebase.firestore.FieldValue.serverTimestamp() }); } }); await batch.commit(); await onFloorChange(selectedFloor); showAlert('âœ… ç©ºé–“åˆ†é…å·²å„²å­˜æˆåŠŸï¼', 'success'); } catch (error) { showAlert('å„²å­˜å¤±æ•—: ' + error.message, 'error'); } finally { showLoading(false); } }
    function onQuantityChange(inputElement) { const itemId = inputElement.dataset.itemId; const allInputsForRow = document.querySelectorAll(`input[data-item-id="${itemId}"]`); const distributedCell = document.getElementById(`distributed-${itemId}`); const itemRow = distributedCell.closest('tr'); const totalQuantity = parseFloat(itemRow.dataset.totalQuantity) || 0; let currentDistributed = 0; allInputsForRow.forEach(input => { currentDistributed += (Number(input.value) || 0); }); if (currentDistributed > totalQuantity) { inputElement.value = (Number(inputElement.value) || 0) - (currentDistributed - totalQuantity); showAlert(`åˆ†é…ç¸½æ•¸ (${currentDistributed}) å·²è¶…éæ­¤æ¨“å±¤ç¸½é‡ (${totalQuantity})ï¼Œå·²è‡ªå‹•ä¿®æ­£ã€‚`, 'warning'); currentDistributed = totalQuantity; } const strongTag = distributedCell.querySelector('strong'); if(strongTag) strongTag.textContent = currentDistributed; distributedCell.classList.toggle('error', currentDistributed > totalQuantity); }
    function setupEventListeners() { document.getElementById('projectSelect')?.addEventListener('change', (e) => onProjectChange(e.target.value)); document.getElementById('tenderSelect')?.addEventListener('change', (e) => onTenderChange(e.target.value)); document.getElementById('majorItemSelect')?.addEventListener('change', (e) => onMajorItemChange(e.target.value)); document.getElementById('floorSelect')?.addEventListener('change', (e) => onFloorChange(e.target.value)); document.getElementById('saveSpaceDistributionsBtn')?.addEventListener('click', saveAllSpaceDistributions); document.getElementById('spaceManagerBtn')?.addEventListener('click', showSpaceManager); document.getElementById('addCustomSpaceBtn')?.addEventListener('click', addCustomSpace); document.getElementById('clearAllSpacesBtn')?.addEventListener('click', clearAllSpaces); document.getElementById('saveSpaceSettingsBtn')?.addEventListener('click', saveSpaceSettings); document.getElementById('cancelSpaceModalBtn')?.addEventListener('click', () => closeModal('spaceModal')); document.getElementById('importBtn')?.addEventListener('click', () => document.getElementById('importInput').click()); document.getElementById('importInput')?.addEventListener('change', handleFileImport); document.getElementById('exportBtn')?.addEventListener('click', exportToExcel); }
    function exportToExcel() { if (!selectedFloor || detailItems.length === 0) { return showAlert('æ²’æœ‰è³‡æ–™å¯åŒ¯å‡º', 'error'); } const header = ['é …æ¬¡', 'é …ç›®åç¨±', 'å–®ä½', 'æ¨“å±¤ç¸½é‡', ...spaces]; const data = [header]; detailItems.forEach(item => { const row = document.querySelector(`tr[data-item-id="${item.id}"]`); if (!row) return; const floorTotal = row.querySelector(`#total-qty-${item.id} strong`)?.textContent || '0'; const rowData = [item.sequence || '', item.name || '', item.unit || '', floorTotal]; if (spaces.length > 0) { spaces.forEach(space => { const input = row.querySelector(`input[data-space="${space}"]`); rowData.push(input ? input.value : '0'); }); } data.push(rowData); }); const worksheet = XLSX.utils.aoa_to_sheet(data); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, `${selectedFloor}ç©ºé–“åˆ†é…`); const fileName = `${selectedProject.name}_${selectedTender.name}_${selectedFloor}_ç©ºé–“åˆ†é…è¡¨.xlsx`; XLSX.writeFile(workbook, fileName); }
    async function handleFileImport(event) { const file = event.target.files[0]; if (!file || !selectedFloor) return; const reader = new FileReader(); reader.onload = async (e) => { try { showLoading(true, "æ­£åœ¨è®€å– Excel..."); const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, { type: 'array' }); const worksheet = workbook.Sheets[workbook.SheetNames[0]]; const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }); const importedHeader = jsonData[0]; const importedSpaces = importedHeader.slice(4); if (JSON.stringify(importedSpaces) !== JSON.stringify(spaces)) { const newSpaces = importedSpaces.filter(s => !spaces.includes(s)); if (newSpaces.length > 0) { const confirmed = confirm(`åµæ¸¬åˆ°æ–°çš„ç©ºé–“æ¬„ä½ï¼š\n\n[${newSpaces.join(', ')}]\n\næ˜¯å¦è¦å°‡é€™äº›æ–°ç©ºé–“è‡ªå‹•æ–°å¢è‡³ '${selectedFloor}' çš„è¨­å®šä¸­ï¼Ÿ`); if (confirmed) { spaces = [...spaces, ...newSpaces]; await _performSaveSpaceSettings(); } else { showAlert('åŒ¯å…¥å·²å–æ¶ˆã€‚', 'info'); return; } } } showLoading(true, "æ­£åœ¨å¡«å…¥è³‡æ–™..."); jsonData.slice(1).forEach(row => { const sequence = row[0]; const targetItem = detailItems.find(item => String(item.sequence) === String(sequence)); if (targetItem) { spaces.forEach((space, index) => { const quantity = parseInt(row[index + 4]) || 0; const input = document.querySelector(`input[data-item-id="${targetItem.id}"][data-space="${space}"]`); if (input && quantity > 0) { input.value = quantity; } }); const firstInput = document.querySelector(`input[data-item-id="${targetItem.id}"]`); if(firstInput) onQuantityChange(firstInput); } }); showAlert('åŒ¯å…¥æˆåŠŸï¼è«‹æª¢æŸ¥è¡¨æ ¼å…§å®¹ä¸¦è¨˜å¾—é»æ“Šã€Œå„²å­˜ç©ºé–“åˆ†é…ã€ã€‚', 'success'); } catch (error) { showAlert('åŒ¯å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºã€‚ ' + error.message, 'error'); } finally { showLoading(false); event.target.value = ''; } }; reader.readAsArrayBuffer(file); }
    function showSpaceManager() { if (!selectedFloor) return showAlert('è«‹å…ˆé¸æ“‡ä¸€å€‹æ¨“å±¤', 'warning'); document.getElementById('currentFloorName').textContent = selectedFloor; displayCurrentSpaces(); document.getElementById('spaceModal').style.display = 'flex'; }
    function displayCurrentSpaces() { const container = document.getElementById('currentSpacesList'); container.innerHTML = spaces.length === 0 ? '<p style="color: #6c757d;">å°šæœªè¨­å®šç©ºé–“</p>' : spaces.map(space => `<div class="floor-tag"><span>${space}</span><button data-space="${space}" class="remove-floor-btn">&times;</button></div>`).join(''); container.querySelectorAll('.remove-floor-btn').forEach(btn => btn.onclick = () => { spaces = spaces.filter(s => s !== btn.dataset.space); displayCurrentSpaces(); }); }
    function addCustomSpace() { const input = document.getElementById('newSpaceInput'); const values = input.value.trim().toUpperCase(); if (!values) return; const newSpaces = values.split(/,|ã€/).flatMap(val => { val = val.trim(); if (val.includes('-')) { const [startStr, endStr] = val.split('-'); const prefixMatch = startStr.match(/^\D+/); const prefix = prefixMatch ? prefixMatch[0] : ''; const startNum = parseInt(startStr.replace(prefix, '')); const endNum = parseInt(endStr.replace(/^\D+/, '')); if (!isNaN(startNum) && !isNaN(endNum) && startNum <= endNum) { return Array.from({length: endNum - startNum + 1}, (_, i) => `${prefix}${startNum + i}`); } } return val; }).filter(Boolean); newSpaces.forEach(s => { if (!spaces.includes(s)) spaces.push(s); }); displayCurrentSpaces(); input.value = ''; }
    function clearAllSpaces() { if(confirm('ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰ç©ºé–“å—ï¼Ÿ')){ spaces = []; displayCurrentSpaces(); } }
    async function _performSaveSpaceSettings() { try { const settingData = { tenderId: selectedTender.id, projectId: selectedProject.id, floorName: selectedFloor, spaces: spaces, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }; const query = await safeFirestoreQuery("spaceSettings", [{ field: "tenderId", operator: "==", value: selectedTender.id }, { field: "floorName", operator: "==", value: selectedFloor }, { field: "projectId", operator: "==", value: selectedProject.id }]); if (query.docs.length > 0) { await db.collection("spaceSettings").doc(query.docs[0].id).update(settingData); } else { settingData.createdBy = auth.currentUser.email; settingData.createdAt = firebase.firestore.FieldValue.serverTimestamp(); await db.collection("spaceSettings").add(settingData); } } catch (error) { throw error; } }
    function saveSpaceSettings() { closeModal('spaceModal'); setTimeout(async () => { showLoading(true, 'è¨­å®šå„²å­˜ä¸­...'); try { await _performSaveSpaceSettings(); await onFloorChange(selectedFloor); showAlert('âœ… ç©ºé–“è¨­å®šå·²å„²å­˜ï¼', 'success'); } catch (error) { showAlert('å„²å­˜å¤±æ•—: ' + error.message, 'error'); } finally { showLoading(false); } }, 10); }
    function resetSelects(from = 'project') { const selects = ['tender', 'majorItem', 'floor', 'space']; const startIdx = selects.indexOf(from); for (let i = startIdx; i < selects.length; i++) { const select = document.getElementById(`${selects[i]}Select`); if(select) { select.innerHTML = `<option value="">è«‹å…ˆé¸æ“‡ä¸Šä¸€å€‹é¸é …</option>`; select.disabled = true; } } hideContent(); }
    function hideContent() { document.getElementById('mainContent').style.display = 'none'; document.getElementById('initialEmptyState').style.display = 'flex'; document.getElementById('noSpacesState').style.display = 'none'; }
    function showContent() { document.getElementById('mainContent').style.display = 'block'; document.getElementById('initialEmptyState').style.display = 'none'; }
    function closeModal(modalId) { const modal = document.getElementById(modalId); if (modal) modal.style.display = 'none'; }
    function showLoading(isLoading, message='è¼‰å…¥ä¸­...') { const loadingEl = document.getElementById('loading'); if (loadingEl) { loadingEl.style.display = isLoading ? 'flex' : 'none'; const p = loadingEl.querySelector('p'); if (p) p.textContent = message; } }
    function naturalSequenceSort(a, b) { const re = /(\d+(\.\d+)?)|(\D+)/g; const pA = String(a.sequence||'').match(re)||[], pB = String(b.sequence||'').match(re)||[]; for(let i=0; i<Math.min(pA.length, pB.length); i++) { const nA=parseFloat(pA[i]), nB=parseFloat(pB[i]); if(!isNaN(nA)&&!isNaN(nB)){if(nA!==nB)return nA-nB;} else if(pA[i]!==pB[i])return pA[i].localeCompare(pB[i]); } return pA.length-pB.length; }
    function populateSelect(selectEl, options, defaultText, emptyText) { let html = `<option value="">${defaultText}</option>`; if (options.length === 0 && emptyText) { html += `<option value="" disabled>${emptyText}</option>`; } else { options.forEach(option => { html += `<option value="${option.id}">${option.name}</option>`; }); } selectEl.innerHTML = html; selectEl.disabled = (options.length === 0); }
    function sortFloors(a, b) { const getFloorParts = (floorStr) => { const s = String(floorStr).toUpperCase(); const buildingPrefixMatch = s.match(/^([^\dBRF]+)/); const buildingPrefix = buildingPrefixMatch ? buildingPrefixMatch[1] : ''; const floorMatch = s.match(/([B|R]?)(\d+)/); if (!floorMatch) return { building: buildingPrefix, type: 2, num: 0, raw: s }; const [, type, numStr] = floorMatch; const floorType = (type === 'B') ? 0 : (type === 'R') ? 2 : 1; return { building: buildingPrefix, type: floorType, num: parseInt(numStr, 10), raw: s }; }; const partsA = getFloorParts(a); const partsB = getFloorParts(b); if (partsA.building.localeCompare(partsB.building) !== 0) return partsA.building.localeCompare(partsB.building, 'zh-Hans-CN-u-kn-true'); if (partsA.type !== partsB.type) return partsA.type - partsB.type; if (partsA.type === 0) return partsB.num - partsA.num; if(partsA.num !== partsB.num) return partsA.num - partsB.num; return a.localeCompare(b, 'zh-Hans-CN-u-kn-true'); }
    
        // --- å•Ÿå‹•é é¢ ---
        initializePage();

    }); // waitForElement çµæŸ
}
